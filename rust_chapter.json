[
    "Introducing Rust This chapter covers * Introducing Rust\u2019s features and goals * Exposing Rust\u2019s syntax * Discussing where to use Rust and when to avoid it * Building your first Rust program * Explaining how Rust compares to object-oriented and wider languages\n\n",
    "Welcome to Rust\u2014the empowering programming language. Once you scratch its surface, you will not only find a programming language with unparalleled speed and safety, but one that is enjoyable enough to use every day.\n\n",
    "When you begin to program in Rust, it\u2019s likely that you will want to continue to do so. And this book, Rust in Action, will build your confidence as a Rust program- mer. But it will not teach you how to program from the beginning. This book is intended to be read by people who are considering Rust as their next language and for those who enjoy implementing practical working examples. Here is a list of some of the larger examples this book includes: * Mandelbrot set renderer * A grep clone * Rust in Action * CPU emulator * Generative art * A database * HTTP, NTP, and hexdump clients * LOGO language interpreter * Operating system kernel\n\n",
    "As you may gather from scanning through that list, reading this book will teach you more than just Rust. It also introduces you to systems programming and low-level programming. As you work through Rust in Action, you\u2019ll learn about the role of an operating system (OS), how a CPU works, how computers keep time, what pointers are, and what a data type is. You will gain an understanding of how the computer\u2019s internal sys- tems interoperate. Learning more than syntax, you will also see why Rust was created and the challenges that it addresses.\n\n",
    "1.1 Where is Rust used? Rust has won the \"most loved programming language\" award in Stack Overflow\u2019s annual developer survey every year in 2016-2020. Perhaps that\u2019s why large technology leaders such as the following have adopted Rust: * Amazon Web Services (AWS) has used Rust since 2017 for its serverless comput- ing offerings, AWS Lambda and AWS Fargate. With that, Rust has gained fur- ther inroads. The company has written the Bottlerocket OS and the AWS Nitro System to deliver its Elastic Compute Cloud (EC2) service. * Cloudflare develops many of its services, including its public DNS, serverless computing, and packet inspection offerings with Rust. * Dropbox rebuilt its backend warehouse, which manages exabytes of storage, with Rust. * Google develops parts of Android, such as its Bluetooth module, with Rust. Rust is also used for the crosvmcomponent of Chrome OS and plays an important role in Google\u2019s new operating system, Fuchsia. * Facebook uses Rust to power Facebook\u2019s web, mobile, and API services, as well as parts of HHVM, the HipHop virtual machine used by the Hack programming language. * Microsoft writes components of its Azure platform including a security daemon for its Internet of Things (IoT) service in Rust. * Mozilla uses Rust to enhance the Firefox web browser, which contains 15 mil- lion lines of code. Mozilla\u2019s first two Rust-in-Firefox projects, its MP4 metadata parser and text encoder/decoder, led to overall performance and stability improvements. * GitHub\u2019s npm, Inc., uses Rust to deliver \"upwards of 1.3 billion package down- loads per day.\" * Oracle developed a container runtime with Rust to overcome problems with the Go reference implementation. * Samsung, via its subsidiary SmartThings, uses Rust in its Hub, which is the firm- ware backend for its Internet of Things (IoT) service.\n\n",
    "Rust is also productive enough for fast-moving startups to deploy it. Here are a few examples: * Sourcegraph uses Rust to serve syntax highlighting across all of its languages. * Figma employs Rust in the performance-critical components of its multi-player server.10 * Parity develops its client to the Ethereum blockchain with Rust.\n\n",
    "1.2 Advocating for Rust at work What is it like to advocate for Rust at work? After overcoming the initial hurdle, it tends to go well. A 2017 discussion, reprinted below, provides a nice anecdote. One member of Google\u2019s Chrome OS team discusses what it was like to introduce the language to the project:\n\n",
    "indy on Sept 27, 2017 Is Rust an officially sanctioned language at Google?\n\n",
    "zaxcellent on Sept 27, 2017 Author here: Rust is not officially sanctioned at Google, but there are pockets of folks using it here. The trick with using Rust in this component was convincing my coworkers that no other language was right for job, which I believe to be the case in this instance. That being said, there was a ton of work getting Rust to play nice within the Chrome OS build environment. The Rust folks have been super helpful in answering my questions though.\n\n",
    "ekidd on Sept 27, 2017 The trick with using Rust in this component was convincing my coworkers that no other language was right for job, which I believe to be the case in this instance. I ran into a similar use case in one of my own projects\u2014a vobsub subtitle decoder, which parses complicated binary data, and which I someday want to run as web service. So obviously, I want to ensure that there are no vulnerabilities in my code. I wrote the code in Rust, and then I used \"cargo fuzz\" to try and find vulnerabilities. After running a billion(!) fuzz iterations, I found 5 bugs (see the \"vobsub\" section of the trophy case for a list https://github.com/rust-fuzz/trophy-case). Happily, not one of those bugs could actually be escalated into an actual exploit. In each case, Rust\u2019s various runtime checks successfully caught the problem and turned it into a controlled panic. (In practice, this would restart the web server cleanly.) So my takeaway from this was that whenever I want a language (1) with no GC, but (2) which I can trust in a security-critical context, Rust is an excellent choice. The fact that I can statically link Linux binaries (like with Go) is a nice plus.\n\n",
    "Manishearth on Sept 27, 2017 Happily, not one of those bugs could actually be escalated into an actual exploit. In each case, Rust\u2019s various runtime checks successfully caught the problem and turned it into a controlled panic. This has been more or less our experience with fuzzing rust code in firefox too, fwiw. Fuzzing found a lot of panics (and debug assertions / \"safe\" overflow assertions). In one case it actually found a bug that had been under the radar in the analogous Gecko code for around a decade.\n\n",
    "From this excerpt, we can see that language adoption has been \"bottom up\" by engi- neers looking to overcome technical challenges in relatively small projects. Experi- ence gained from these successes is then used as evidence to justify undertaking more ambitious work.\n\n",
    "In the time since late 2017, Rust has continued to mature and strengthen. It has become an accepted part of Google\u2019s technology landscape, and is now an officially sanctioned language within the Android and Fuchsia operating systems.\n\n",
    "1.3 A taste of the language This section gives you a chance to experience Rust firsthand. It demonstrates how to use the compiler and then moves on to writing a quick program. We tackle full proj- ects in later chapters.\n\n",
    "NOTE To install Rust, use the official installers provided at https://rustup.rs/.\n\n",
    "The first thing that most programmers do when they reach for a new programming language is to learn how to print \"Hello, world!\" to the console. You\u2019ll do that too, but with flair. You\u2019ll verify that everything is in working order before you encounter annoying syntax errors.\n\n",
    "If you use Windows, open the Rust command prompt that is available in the Start menu after installing Rust. Then execute this command:\n\n",
    "C:\\> cd %TMP% ",
    "If you are running Linux or macOS, open a Terminal window. Once open, enter the following:\n\n",
    "$ cd $TMP ",
    "From this point forward, the commands for all operating systems should be the same. If you installed Rust correctly, the following three commands will display \"Hello, world!\" on the screen (as well as a bunch of other output):\n\n",
    " $ cargo new hello\n $ cd hello\n $ cargo run",
    "Here is an example of what the entire session looks like when running cmd.exe on MS Windows:\n\n",
    " C:\\> cd %TMP%\n C:\\Users\\Tim\\AppData\\Local\\Temp\\> cargo new hello\n\n   Created binary (application) `hello` project\n\n C:\\Users\\Tim\\AppData\\Local\\Temp\\> cd hello\n C:\\Users\\Tim\\AppData\\Local\\Temp\\hello\\> cargo run\n\n           Compiling hello v0.1.0 (file:///C:/Users/Tim/AppData/Local/Temp/hello)\n            Finished dev [unoptimized + debuginfo] target(s) in 0.32s\n             Running `target\\debug\\hello.exe`\n        Hello, world!",
    "And on Linux or macOS, your console would look like this:\n\n",
    " $ cd $TMP\n        $ cargo new hello**\n    Created binary (application) `hello` package\n $ cd hello\n $ cargo run**\n           Compiling hello v0.1.0 (/tmp/hello)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.26s\n     Running `target/debug/hello`\n     Hello, world!",
    "If you have made it this far, fantastic! You have run your first Rust code without needing to write any Rust. Let\u2019s take a look at what just happened.\n\n",
    "Rust\u2019s cargo tool provides both a build system and a package manager. That means cargo knows how to convert your Rust code into executable binaries and also can manage the process of downloading and compiling the project\u2019s dependencies.\n\n",
    "cargo newcreates a project for you that follows a standard template. The treecommand can reveal the default project structure and the files that are created after issuing cargo new:\n\n",
    "$ tree hello\nhello\n\u251c\u2500\u2500 Cargo.toml \u2514\u2500\u2500 src\n\u2514\u2500\u2500 main.rs\n1 directory, 2 files",
    "All Rust projects created with cargo have the same structure. In the base directory, a file called Cargo.toml describes the project\u2019s metadata, such as the project\u2019s name, its version, and its dependencies. Source code appears in the src directory. Rust source code files use the .rs filename extension. To view the files that cargo newcreates, use the treecommand.\n\n",
    "The next command that you executed was cargo run. This line is much simpler to grasp, but cargo actually did much more work than you realized. You asked cargo to run the project. As there was nothing to actually run when you invoked the command, it decided to compile the code in debug mode on your behalf to provide maximal error information. As it happens, the src/main.rs file always includes a \"Hello, world!\" stub. The result of that compilation was a file called hello (or hello.exe). The hello file was executed, and the result printed to your screen. Executing cargo runhas also added new files to the project. We now have a Cargo.lock file in the base of our project and a target/ directory. Both that file and the directory are managed by cargo. Because these are artifacts of the compilation process, we won\u2019t need to touch these. Cargo.lock is a file that specifies the exact ver- sion numbers of all the dependencies so that future builds are reliably built the same way until Cargo.toml is modified.\n\n",
    "Running treeagain reveals the new structure created by invoking cargo runto compile the hello project:\n\n",
    "$ tree --dirsfirst hello\nhello\n\u251c\u2500\u2500 src\n\u2502 \u2514\u2500\u2500 main.rs\n\u251c\u2500\u2500 target\n\u2502 \u2514\u2500\u2500 debug\n\u2502 \u251c\u2500\u2500 build\n\u2502 \u251c\u2500\u2500 deps\n\u2502 \u251c\u2500\u2500 examples\n\u2502 \u251c\u2500\u2500 native\n\u2502 \u2514\u2500\u2500 hello \u251c\u2500\u2500 Cargo.lock \u2514\u2500\u2500 Cargo.toml",
    "For getting things up and running, well done! Now that we\u2019ve cheated our way to \"Hello, World!\", let\u2019s get there via the long way.\n\n",
    "1.3.2 Your first Rust program For our first program, we want to write something that outputs the following text in multiple languages:\n\n",
    "Hello, world!\nGr\u00fc\u00df Gott!\n\u30cf\u30ed\u30fc\u30fb\u30ef\u30fc\u30eb\u30c9",
    "You have probably seen the first line in your travels. The other two are there to highlight a few of Rust\u2019s features: easy iteration and built-in support for Unicode. For this program, we\u2019ll use cargo to create it as before. Here are the steps to follow: 1 Open a console prompt. 2 Run cd %TMP% on MS Windows; otherwise cd $TMP. 3 Run cargo new hello2 to create a new project. 4 Run cd hello2 to move into the project\u2019s root directory. 5 Open the file src/main.rs in a text editor. 6 Replace the text in that file with the text in listing\n\n",
    "Listing 1.1 \"Hello World!\" in three languages\n\n",
    "1 fn greet_world(){\n2 println!(\"Hello, world!\");\n3 let southern germany = \"Gr\u00fc\u00df Gott!\";\n4 let japan\n = \"\u30cf\u30ed\u30fc\u00b7\u30ef\u30fc\u30eb\u30c9\";\n5 let regions = [southern germany, japan];\n6 for region in regions.iter() {\n7 println!(\"{}\", &region);\n8    }\n9 }\n10\n11 fn main(){\n12 greet_world();\n13 }",
    "Now that src/main.rs is updated, execute cargo run from the hello2/ directory. You should see three greetings appear after some output generated from cargo itself:\n\n",
    "$ cargo run\n   Compiling hello2 v0.1.0 (/path/to/ch1/ch1-hello2)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.95s\n     Running `target/debug/hello2`\nHello, world!\nGr\u00fc\u00df Gott!\n\u30cf\u30ed\u30fc\u30fb\u30ef\u30fc\u30eb\u30c9",
    "Let\u2019s take a few moments to touch on some of the interesting elements of Rust from listing 1.1.\n\n",
    "One of the first things that you are likely to notice is that strings in Rust are able to include a wide range of characters. Strings are guaranteed to be encoded as UTF-8. This means that you can use non-English languages with relative ease.\n\n",
    "The one character that might look out of place is the exclamation mark after println. If you have programmed in Ruby, you may be used to thinking that it is used to signal a destructive operation. In Rust, it signals the use of a macro. Macros can be thought of as fancy functions for now. These offer the ability to avoid boilerplate code. In the case of println!, there is a lot of type detection going on under the hood so that arbitrary data types can be printed to the screen.\n\n",
    "1.4 Downloading the book\u2019s source code In order to follow along with the examples in this book, you might want to access the source code for the listings. For your convenience, source code for every example is available from two sources: https://manning.com/books/rust-in-action https://github.com/rust-in-action/code\n\n",
    "1.5 What does Rust look and feel like? Rust is the programming language that allows Haskell and Java programmers to get along. Rust comes close to the high-level, expressive feel of dynamic languages like Haskell and Java while achieving low-level, bare-metal performance.\n\n",
    "We looked at a few \"Hello, world!\" examples in section 1.3, so let\u2019s try something slightly more complex to get a better feel for Rust\u2019s features. Listing 1.2 provides a quick look at what Rust can do for basic text processing. The source code for this list- ing is in the ch1/ch1-penguins/src/main.rs file. Some features to notice include * Common control flow mechanisms\u2014This includes forloops and the continuekeyword. * Method syntax\u2014Although Rust is not object-oriented as it does not support inheritance, it carries over this feature of object-oriented languages. * Higher-order programming\u2014Functions can both accept and return functions. For example, line 19 (.map(|field| field.trim()))includes a closure, also known as an anonymous function or lambda function.  Type annotations\u2014Although relatively rare, these are occasionally required as a hint to the compiler (for example, see line 27 beginning with if let Ok(length)). * Conditional compilation\u2014In the listing, lines 21\u201324 (ifcfg!(...);) are not included in release builds of the program. * Implicit return\u2014Rust provides a returnkeyword, but it\u2019s usually omitted. Rust is an expression-based language.\n\n",
    "Listing 1.2 Example of Rust code showing some basic processing of CSV data\n\n",
    "1 fn main(){\n2 let penguin data = \"\\\n3 common name,length (cm)\n4 Little penguin, 33\n5 Yellow-eyed penguin, 65\n6 Fiordland penguin, 60\n7 Invalid, data\n8 \" ;\n9\n10 let records = penguin_data.lines ();\n11\n12 for (i, record) in records.enumerate()\n13 if i == 0 || record.trim().len() ==\n14 continue;\n15 }\n16\n17 let fields: Vec<_> = record \n18 .split (',')\n19 .map(|field| field.trim())\n20 .collect ();\n21 if cfg! (debug_assertions) {\n22 eprintln! (\"debug: {:?} -> {:?}\",\n23 record, fields);\n24 }\n25\n26 let name = fields [0];\n27 if let Ok(length) = fields[1].parse: :<f32>(){\n28 println!(\"{}, {}cm\", name, length);\n29  }\n30 }\n31}",
    "Listing 1.2 might be confusing to some readers, especially those who have never seen Rust before. Here are some brief notes before moving on: * On line 17, the fieldsvariable is annotated with the type Vec<_>. Vecis short- hand for _vector_, a collection type that can expand dynamically. The under- score (_) instructs Rust to infer the type of the elements. * On lines 22 and 28, we instruct Rust to print information to the console. The println!macro prints its arguments to standard out (stdout), whereas eprintln!prints to standard error (stderr). * Macros are similar to functions except that instead of returning data, these return code. Macros are often used to simplify common patterns. * eprintln!and println!both use a string literal with an embedded mini- language in their first argument to control their output. The {}placeholder tells Rust to use a programmer-defined method to represent the value as a string rather than the default representation available with {:?}. * Line 27 contains some novel features. if let Ok(length) = fields[1].parse ::<f32>()reads as \"attempt to parse fields[1]as a 32-bit floating-point num- ber and, if that is successful, then assign the number to the length variable.\" * The if letconstruct is a concise method of conditionally processing data that also provides a local variable assigned to that data. The parse()method returns Ok(T)(where Tstands for any type) when it can successfully parse the string; otherwise, it returns Err(E)(where Estands for an error type). The effect of if let Ok(T)is to skip any error cases like the one that\u2019s encountered while processing the line Invalid,data. * When Rust is unable to infer the types from the surrounding context, it will ask for you to specify those. The call to parse()includes an inline type annota- tion as parse::<f32>().\n\n",
    "Converting source code into an executable file is called compiling. To compile Rust code, we need to install the Rust compiler and run it against the source code. To com- pile listing 1.2, follow these steps: 1 Open a console prompt (such as cmd.exe, PowerShell, Terminal, or Alacritty). 2 Move to the ch1/ch1-penguins directory (not ch1/ch1-penguins/src) of the source code you downloaded in section 1.4. 3 Execute cargo run. Its output is shown in the following code snippet:\n\n",
    "$ cargo run\n         Compiling ch1-penguins v0.1.0 (../code/ch1/ch1-penguins)\n          Finished dev [unoptimized + debuginfo] target(s) in 0.40s\n           Running `target/debug/ch1-penguins`\n      dbg: \"  Little penguin,33\" -> [\"Little penguin\", \"33\"]\n      Little penguin, 33cm\n      dbg: \"  Yellow-eyed penguin,65\" -> [\"Yellow-eyed penguin\", \"65\"]\n      Yellow-eyed penguin, 65cm\n      dbg: \"  Fiordland penguin,60\" -> [\"Fiordland penguin\", \"60\"]\n      Fiordland penguin, 60cm\n      dbg: \"  Invalid,data\" -> [\"Invalid\", \"data\"]",
    "You probably noticed the distracting lines starting with dbg:. We can eliminate these by compiling a release build using cargo\u2019s --release flag. This conditional compilation functionality is provided by the cfg!(debug_assertions) { ... } block within lines 22\u201324 of listing 1.2. Release builds are much faster at runtime, but incur longer compilation times:\n\n",
    " $ cargo run --release\n           Compiling ch1-penguins v0.1.0 (.../code/ch1/ch1-penguins)\n            Finished release [optimized] target(s) in 0.34s\n             Running `target/release/ch1-penguins`\n        Little penguin, 33cm\n        Yellow-eyed penguin, 65cm\n        Fiordland penguin, 60cm",
    "It\u2019s possible to further reduce the output by adding the -qflag to cargocommands. -qis shorthand for quiet. The following snippet shows what that looks like:\n\n",
    "$ cargo run -q --release\n        Little penguin, 33cm\n        Yellow-eyed penguin, 65cm\n        Fiordland penguin, 60cm",
    "Listing 1.1 and listing 1.2 were chosen to pack as many representative features of Rust into examples that are easy to understand. Hopefully these demonstrated that Rust pro- grams have a high-level feel, paired with low-level performance. Let\u2019s take a step back from specific language features now and consider some of the thinking behind the language and where it fits within the programming language ecosystem.\n\n",
    "1.6 What is Rust? Rust\u2019s distinguishing feature as a programming language is its ability to prevent invalid data access at compile time. Research projects by Microsoft\u2019s Security Response Center and the Chromium browser project both suggest that issues relating to invalid data access account for approximately 70% of serious security bugs.13 Rust eliminates that class of bugs. It guarantees that your program is memory-safe without imposing any run- time costs.\n\n",
    "Other languages can provide this level of safety, but these require adding checks that execute while your program is running, thus slowing it down. Rust manages to break out of this continuum, creating its own space as illustrated by figure 1.1.\n\n",
    "Rust\u2019s distinguishing feature as a professional community is its willingness to explicitly include values into its decision-making process. This ethos of inclusion is pervasive. Public messaging is welcoming. All interactions within the Rust community are governed by its code of conduct. Even the Rust compiler\u2019s error messages are ridiculously helpful.\n\n",
    "Until late 2018, visitors to the Rust home page were greeted with the (technically heavy) message, \"Rust is a systems programming language that runs blazingly fast, pre- vents segfaults, and guarantees thread safety.\" At that point, the community imple- mented a change to its wording to put its users (and its potential users) at the center (table 1.1).\n\n",
    "Table 1.1 Rust slogans over time. As Rust has developed its confidence, it has increasingly embraced the idea of acting as a facilitator and supporter of everyone wanting to achieve their programming aspirations.\n\n",
    "| Until late 2018| From that point onward| \n| -------- | -------- | \n| \u201cRust is a systems programming language that runs blazingly  fast, prevents segfaults, and guarantees thread safety.\u201d  | \u201cEmpowering everyone to build reliable and efficient software.\u201d |\n",
    "Rust is labelled as a systems programming language, which tends to be seen as quite a spe- cialized, almost esoteric branch of programming. However, many Rust programmers have discovered that the language is applicable to many other domains. Safety, pro- ductivity, and control are useful in all software engineering projects. Moreover, the Rust community\u2019s inclusiveness means that the language benefits from a steady stream of new voices with diverse interests.\n\n",
    "Let\u2019s flesh out those three goals: safety, productivity, and control. What are these and why do these matter?\n\n",
    "1.6.1 Goal of Rust: Safety Rust programs are free from * Dangling pointers\u2014Live references to data that has become invalid over the course of the program (see listing 1.3) * Data races\u2014The inability to determine how a program will behave from run to run because external factors change (see listing 1.4) * Buffer overflow\u2014An attempt to access the 12th element of an array with only 6 elements (see listing 1.5) * Iterator invalidation\u2014An issue caused by something that is iterated over after being altered midway through (see listing 1.6)\n\n",
    "When programs are compiled in debug mode, Rust also protects against integer over- flow. What is integer overflow? Well, integers can only represent a finite set of num- bers; these have a fixed-width in memory. Integer overflow is what happens when the integers hit their limit and flow over to the beginning again.\n\n",
    "The following listing shows a dangling pointer. Note that you\u2019ll find this source code in the ch1/ch1-cereals/src/main.rs file.\n\n",
    "Listing 1.3 Attempting to create a dangling pointer\n\n",
    "1 #[derive (Debug)]\n2 enum Cereal\n3 Barley, Millet, Rice,\n4 Rye, Spelt, Wheat,\n5 }\n6\n7 fn main() {\n8 let mut grains: Vec<Cereal> = vec! [];\n9 grains.push (Cereal::Rye);\n10 drop (grains);\n11 println! (\"{:?}\", grains);\n12 }",
    "Listing 1.3 contains a pointer within grains, which is created on line 8. Vec is implemented with an internal pointer to an underlying array. But the listing does not compile. An attempt to do so triggers an error message that complains about attempting to \"borrow\" a \"moved\" value. Learning how to interpret that error message and to fix the underlying error are topics for the pages to come. Here\u2019s the output from attempting to compile the code for listing 1.3:\n\n",
    "$ cargo run\n   Compiling ch1-cereals v0.1.0 (/rust-in-action/code/ch1/ch1-cereals)\nerror[E0382]: borrow of moved value: `grains`\n  --> src/main.rs:12:22\n   |\n8  | let mut grains: Vec<Cereal> = vec![];\n   | ------- move occurs because `grains` has type\n           `std::vec::Vec<Cereal>`, which does not implement the `Copy` trait\n9  |grains.push(Cereal::Rye);\n10 |drop(grains);\n     ------ value moved here\n11 |\n12 |println!(\"{:?}\", grains);\n   |          value borrowed here after move\n\nerror: aborting due to previous error\n    \nFor more information about this error, try `rustc --explain E0382`.\nerror: could not compile `ch1-cereals`.",
    "Listing 1.4 shows an example of a data race condition. If you remember, this condition results from the inability to determine how a program behaves from run to run due to changing external factors. You\u2019ll find this code in the ch1/ch1-race/src/ main.rs file.\n\n",
    "Listing 1.4 Example of Rust preventing a race condition\n\n",
    "1 use std::thread;\n2 fn main() {\n3     let mut data = 100;\n4\n5     thread::spawn(|| { data = 500; });\n6     thread::spawn(|| { data = 1000; });\n7     println!(\"{}\", data);\n8}",
    "If you are unfamiliar with the term thread, the upshot is that this code is not determin- istic. It\u2019s impossible to know what value data will hold when main() exits. On lines 6 and 7 of the listing, two threads are created by calls to thread::spawn(). Each call takes a closure as an argument, denoted by vertical bars and curly braces (e.g., || {\u2026}). The thread spawned on line 5 is attempting to set the data variable to 500, whereas the thread spawned on line 6 is attempting to set it to 1,000. Because the scheduling of threads is determined by the OS rather than the program, it\u2019s impossible to know if the thread defined first will be the one that runs first.\n\n",
    "Attempting to compile listing 1.5 results in a stampede of error messages. Rust does not allow multiple places in an application to have write access to data. The code attempts to allow this in three places: once within the main thread running main() and once in each child thread created by thread::spawn(). Here\u2019s the compiler message:\n\n",
    "$ cargo run\n   Compiling ch1-race v0.1.0 (rust-in-action/code/ch1/ch1-race)\nerror[E0373]: closure may outlive the current function, but it borrows `data`, which is owned by the current function\n --> src/main.rs:6:19\n  |\n6 |     thread::spawn(|| { data = 500; });\n| ^^ ---- `data` is borrowed here \n|            |\n| may outlive borrowed value `data` |\nnote: function requires argument type to outlive `'static`\n --> src/main.rs:6:5\n  |\n6 |     thread::spawn(|| { data = 500; });\n  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\nhelp: to force the closure to take ownership of `data`\n      (and any other referenced variables), use the `move` keyword\n  |\n  |  thread::spawn(move || { data = 500; });\n  |            ^^^^^^^\n    error: aborting due to 4 previous errors\n    \nSome errors have detailed explanations: E0373, E0499, E0502.\nFor more information about an error, try `rustc --explain E0373`.\nerror: could not compile `ch1-race`.",
    "Listing 1.5 provides an example of a buffer overflow. A buffer overflow describes situa- tions where an attempt is made to access items in memory that do not exist or that are illegal. In our case, an attempt to access fruit[4] results in the program crashing, as the fruit variable only contains three fruit. The source code for this listing is in the file ch1/ch1-fruit/src/main.rs.\n\n",
    "Listing 1.5 Example of invoking a panic via a buffer overflow\n\n",
    "1 fn main() {\n2 let fruit = vec![' ', ' ', ' ']; 3\n4     let buffer_overflow = fruit[4];\n5     assert_eq!(buffer_overflow, '  ')\n6}",
    "When listing 1.5 is compiled and executed, you\u2019ll encounter this error message:\n\n",
    "    $ cargo run\n   Compiling ch1-fruit v0.1.0 (/rust-in-action/code/ch1/ch1-fruit)\n    Finished dev [unoptimized + debuginfo] target(s) in 0.31s\n     Running `target/debug/ch1-fruit`\nthread 'main' panicked at 'index out of bounds:\n    the len is 3 but the index is 4', src/main.rs:3:25\nnote: run with `RUST_BACKTRACE=1` environment variable\n    to display a backtrace",
    "The next listing shows an example of iterator invalidation, where an issue is caused by something that\u2019s iterated over after being altered midway through. The source code for this listing is in ch1/ch1-letters/src/main.rs.\n\n",
    "Listing 1.6 Attempting to modify an iterator while iterating over it\n\n",
    "1 fn main() {\n2     let mut letters = vec![\n3 \"a\", \"b\", \"c\"\n4 ];\n5\n6 for letter in letters {\n7 println!(\"{}\", letter);\n8 letters.push(letter.clone());\n9   }\n10}",
    "Listing 1.6 fails to compile because Rust does not allow the letters variable to be modified within the iteration block. Here\u2019s the error message:\n\n",
    "$ cargo run\n   Compiling ch1-letters v0.1.0 (/rust-in-action/code/ch1/ch1-letters)\nerror[E0382]: borrow of moved value: `letters`\n --> src/main.rs:8:7\n  |\n2 | let mut letters = vec![\n    ----------- move occurs because `letters` has type\n                `std::vec::Vec<&str>`, which does not\n                implement the `Copy` trait\n    ...   \n6 | for letter in letters {\n  |      -------\n  |    |\n  | `letters` moved due to this implicit call\n  |       to `.into_iter()`\n  |  help: consider borrowing to avoid moving\n  |        into the for loop: `&letters`\n7 | println!(\"{}\", letter);\n8 | letters.push(letter.clone());\n  | ^^^^^^^ value borrowed here after move\n\nerror: aborting due to previous error\n    \nFor more information about this error, try `rustc --explain E0382`.\n    \nerror: could not compile `ch1-letters`.\nTo learn more, run the command again with --verbose.",
    "While the language of the error message is filled with jargon (borrow, move, trait, and so on), Rust has protected the programmer from stepping into a trap that many others fall into. And fear not\u2014that jargon will become easier to understand as you work through the first few chapters of this book.\n\n",
    "Knowing that a language is safe provides programmers with a degree of liberty. Because they know their program won\u2019t implode, they become much more willing to experiment. Within the Rust community, this liberty has spawned the expression fear- less concurrency.\n\n",
    "1.6.2 Goal of Rust: Productivity When given a choice, Rust prefers the option that is easiest for the developer. Many of its more subtle features are productivity boosts. But programmer productivity is a diffi- cult concept to demonstrate through an example in a book. Let\u2019s start with something that can snag beginners\u2014using assignment (=) within an expression that should use an equality (==) test:\n\n",
    "1 fn main() {\n2 let a = 10;\n3\n4 if a = 10 {\n5 println!(\"a equals ten\");\n6  } \n7}  ",
    "In Rust, the preceding code fails to compile. The Rust compiler generates the following message:\n\n",
    "error[E0308]: mismatched types\n --> src/main.rs:4:8\n  |\n4 | if a = 10 { \n  | ^^^^^^ \n  |     |\n  |        expected `bool`, found `()`\n  |        help: try comparing for equality: `a == 10`\nerror: aborting due to previous error\nFor more information about this error, try `rustc --explain E0308`.\nerror: could not compile `playground`.\nTo learn more, run the command again with --verbose.",
    "At first, \"mismatched types\" might feel like a strange error message to encounter. Surely we can test variables for equality against integers.\n\n",
    "After some thought, it becomes apparent why the if test receives the wrong type. The if is not receiving an integer. It\u2019s receiving the result of an assignment. In Rust, this is the blank type: (). () is pronounced unit.\n\n",
    "When there is no other meaningful return value, expressions return (). As the fol- lowing shows, adding a second equals sign on line 4 results in a working program that prints a equals ten:\n\n",
    "1 fn main() {\n2 let a = 10;\n3\n4 if a == 10 {\n5 println!(\"a equals ten\");\n6} \n7}",
    "Rust has many ergonomic features. It offers generics, sophisticated data types, pattern matching, and closures.15 Those who have worked with other ahead-of-time compila- tion languages are likely to appreciate Rust\u2019s build system and its comprehensive pack- age manager: cargo.\n\n",
    "At first glance, we see that cargo is a front end for rustc, the Rust compiler, but cargo provides several additional utilities including the following: * cargo new creates a skeleton Rust project in a new directory (cargo init uses the current directory). * cargo build downloads dependencies and compiles the code. * cargo run executes cargo build and then also runs the resulting executable file. * cargo doc builds HTML documentation for every dependency in the current project.\n\n",
    "1.6.3 Goal of Rust: Control Rust offers programmers fine-grained control over how data structures are laid out in memory and their access patterns. While Rust uses sensible defaults that align with its \"zero cost abstractions\" philosophy, those defaults do not suit all situations.\n\n",
    "At times, it is imperative to manage your application\u2019s performance. It might mat- ter to you that data is stored in the stack rather than on the heap. Perhaps, it might make sense to add reference counting to create a shared reference to a value. Occasion- ally, it might be useful to create one\u2019s own type of pointer for a particular access pat- tern. The design space is large and Rust provides the tools to allow you to implement your preferred solution.\n\n",
    "NOTE If terms such as stack, heap, and reference counting are new, don\u2019t put the book down! We\u2019ll spend lots of time explaining these and how they work together throughout the rest of the book.\n\n",
    "Listing 1.7 prints the line a: 10,b:20,c:30,d:Mutex{data:40}. Each represen- tation is another way to store an integer. As we progress through the next few chap- ters, the trade-offs related to each level become apparent. For the moment, the important thing to remember is that the menu of types is comprehensive. You are wel- come to choose exactly what\u2019s right for your specific use case. Listing 1.7 also demonstrates multiple ways to create integers. Each form provides differing semantics and runtime characteristics. But programmers retain full control of the trade-offs that they want to make. Listing 1.7 Multiple ways to create integer values\n\n",
    " 1 use std::rc::Rc;\n 2 use std::sync::{Arc, Mutex};\n 3\n 4 fn main() {\n 5 let a = 10;\n 6     let b = Box::new(20);\n 7     let c = Rc::new(Box::new(30));\n 8     let d = Arc::new(Mutex::new(40));\n 9     println!(\"a: {:?}, b: {:?}, c: {:?}, d: {:?}\", a, b, c, d);\n10 }",
    "To understand why Rust is doing something the way it is, it can be helpful to refer back to these three principles: * The language\u2019s first priority is safety. * Data within Rust is immutable by default. * Compile-time checks are strongly preferred. Safety should be a \"zero-cost abstraction.\"\n\n",
    "1.7 Rust\u2019s big features Our tools shape what we believe we can create. Rust enables you to build the software that you want to make, but were too scared to try. What kind of tool is Rust? Flowing from the three principles discussed in the last section are three overarching features of the language: * Performance * Concurrency * Memory efficiency\n\n",
    "1.7.1 Performance Rust offers all of your computer\u2019s available performance. Famously, Rust does not rely on a garbage collector to provide its memory safety.\n\n",
    "There is, unfortunately, a problem with promising you faster programs: the speed of your CPU is fixed. Thus, for software to run faster, it needs to do less. Yet, the lan- guage is large. To resolve this conflict, Rust pushes the burden onto the compiler.\n\n",
    "The Rust community prefers a bigger language with a compiler that does more, rather than a simpler language where the compiler does less. The Rust compiler aggressively optimizes both the size and speed of your program. Rust also has some less obvious tricks: * Cache-friendly data structures are provided by default. Arrays usually hold data within Rust programs rather than deeply nested tree structures that are created by pointers. This is referred to as data-oriented programming. * The availability of a modern package manager (cargo) makes it trivial to benefit from tens of thousands of open source packages. C and C++ have much less consistency here, and building large projects with many dependencies is typically difficult. * Methods are always dispatched statically unless you explicitly request dynamic dispatch. This enables the compiler to heavily optimize code, sometimes to the point of eliminating the cost of a function call entirely.\n\n",
    "1.7.2 Concurrency Asking a computer to do more than one thing at the same time has proven difficult for software engineers. As far as an OS is concerned, two independent threads of exe- cution are at liberty to destroy each other if a programmer makes a serious mistake. Yet Rust has spawned the expression fearless concurrency. Its emphasis on safety crosses the bounds of independent threads. There is no global interpreter lock (GIL) to con- strain a thread\u2019s speed. We explore some of the implications of this in part 2.\n\n",
    "1.7.3 Memory efficiency Rust enables you to create programs that require minimal memory. When needed, you can use fixed-size structures and know exactly how every byte is managed. High- level constructs, such as iteration and generic types, incur minimal runtime overhead.\n\n",
    "1.8 Downsides of Rust It\u2019s easy to talk about this language as if it is the panacea for all software engineering. For example * \"A high-level syntax with low-level performance!\" * \"Concurrency without crashes!\" * \"C with perfect safety!\" These slogans (sometimes overstated) are great. But for all of its merits, Rust does have some disadvantages.\n\n",
    "1.8.1 Cyclic data structures In Rust, it is difficult to model cyclic data like an arbitrary graph structure. Imple- menting a doubly-linked list is an undergraduate-level computer science problem. Yet Rust\u2019s safety checks do hamper progress here. If you\u2019re new to the language, avoid implementing these sorts of data structures until you\u2019re more familiar with Rust.\n\n",
    "1.8.2 Compile times Rust is slower at compiling code than its peer languages. It has a complex compiler toolchain that receives multiple intermediate representations and sends lots of code to the LLVM compiler. The unit of compilation for a Rust program is not an individ- ual file but a whole package (known affectionately as a crate). As crates can include TLS security case studies 21 multiple modules, these can be exceedingly large units to compile. Although this enables whole-of-crate optimization, it requires whole-of-crate compilation as well.\n\n",
    "1.8.3 Strictness It\u2019s impossible\u2014well, difficult\u2014to be lazy when programming with Rust. Programs won\u2019t compile until everything is just right. The compiler is strict, but helpful.\n\n",
    "Over time, it\u2019s likely that you\u2019ll come to appreciate this feature. If you\u2019ve ever pro- grammed in a dynamic language, then you may have encountered the frustration of your program crashing because of a misnamed variable. Rust brings that frustration forward so that your users don\u2019t have to experience the frustration of things crashing.\n\n",
    "1.8.4 Size of the language Rust is large! It has a rich type system, se several dozen keywords, and includes some fea- tures that are unavailable in other languages. These factors all combine to create a steep learning curve. To make this manageable, I encourage learning Rust gradually. Start with a minimal subset of the language and give yourself time to learn the details when you need these. That is the approach taken in this book. Advanced concepts are deferred until much later.\n\n",
    "1.8.5 Hype The Rust community is wary of growing too quickly and being consumed by hype. Yet, a number of software projects have encountered this question in their Inbox: \"Have you considered rewriting this in Rust?\" Unfortunately, software written in Rust is still software. It not immune to security problems and does not offer a panacea to all of software engineering\u2019s ills.\n\n",
    "1.9 TLS security case studies To demonstrate that Rust will not alleviate all errors, let\u2019s examine two serious exploits that threatened almost all internet-facing devices and consider whether Rust would have prevented those. By 2015, as Rust gained prominence, implementations of SSL/TLS (namely, OpenSSL and Apple\u2019s own fork) were found to have serious security holes. Known informally as Heartbleed and goto fail;, both exploits provide opportunities to test Rust\u2019s claims of memory safety. Rust is likely to have helped in both cases, but it is still possi- ble to write Rust code that suffers from similar issues.\n\n",
    "1.9.1 Heartbleed Heartbleed, officially designated as CVE-2014-0160,16 was caused by re-using a buffer incorrectly. A buffer is a space set aside in memory for receiving input. Data can leak from one read to the next if the buffer\u2019s contents are not cleared between writes. Why does this situation occur? Programmers hunt for performance. Buffers are reused to minimize how often memory applications ask for memory from the OS.\n\n",
    "Imagine that we want to process some secret information from multiple users. We decide, for whatever reason, to reuse a single buffer through the course of the pro- gram. If we don\u2019t reset this buffer once we use it, information from earlier calls will leak to the latter ones. Here is a pr\u00e9cis of a program that would encounter this error:\n\n",
    "let buffer = &mut[0u8; 1024];\n  read_secrets(&user1, buffer);\n  store_secrets(buffer);\n  read_secrets(&user2, buffer);\n  store_secrets(buffer);",
    "Rust does not protect you from logical errors. It ensures that your data is never able to be written in two places at the same time. It does not ensure that your program is free from all security issues.\n\n",
    "1.9.2 Go to fail; The goto fail; bug, officially designated as CVE-2014-1266,17 was caused by program- mer error coupled with C design issues (and potentially by its compiler not pointing out the flaw). A function that was designed to verify a cryptographic key pair ended up skipping all checks. Here is a selected extract from the original SSLVerifySigned- ServerKeyExchange function with a fair amount of obfuscatory syntax retained:18\n\n",
    "1 static OSStatus\n2 SSLVerifySignedServerKeyExchange (SSLContext *ctx,\n3      bool isRsa,\n4      SSLBuffer signedParams, \n5      uint8 t *signature,  \n6      UInt16 signatureLen)\n7{\n8 OSStatus err;\n9 ...\n10\n11 if ((err = SSLHashSHA1.update( \n12 &hashCtx, &serverRandom)) != 0)\n13 go to fail;\n14\n15 if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0)",
    "In the example code, the issue lies between lines 15 and 17. In C, logical tests do not require curly braces. C compilers interpret those three lines like this:\n\n",
    "if ((err = SSLHashSHA1.update(&hashCtx, &signedParams)) != 0) {\ngoto fail; }\ngoto fail;",
    "Would Rust have helped? Probably. In this specific case, Rust\u2019s grammar would have caught the bug. It does not allow logical tests without curly braces. Rust also issues a warning when code is unreachable. But that doesn\u2019t mean the error is made impossi- ble in Rust. Stressed programmers under tight deadlines make mistakes. In general, similar code would compile and run.\n\n",
    "1.10 Where does Rust fit best? Although it was designed as a systems programming language, Rust is a general-purpose language. It has been successfully deployed in many areas, which we discuss next.\n\n",
    "1.10.1 Command-line utilities Rust offers three main advantages for programmers creating command-line utilities: minimal startup time, low memory use, and easy deployment. Programs start their work quickly because Rust does not need to initialize an interpreter (Python, Ruby, etc.) or virtual machine (Java, C#, etc.).\n\n",
    "As a bare metal language, Rust produces memory-efficient programs.19 As you\u2019ll see throughout the book, many types are zero-sized. That is, these only exist as hints to the compiler and take up no memory at all in the running program.\n\n",
    "Utilities written in Rust are compiled as static binaries by default. This compilation method avoids depending on shared libraries that you must install before the pro- gram can run. Creating programs that can run without installation steps makes these easy to distribute.\n\n",
    "1.10.2 Data processing Rust excels at text processing and other forms of data wrangling. Programmers bene- fit from control over memory use and fast startup times. As of mid-2017, Rust touts the world\u2019s fastest regular expression engine. In 2019, the Apache Arrow data-processing project\u2014foundational to the Python and R data science ecosystems\u2014accepted the Rust-based DataFusion project.\n\n",
    "Rust also underlies the implementation of multiple search engines, data-processing engines, and log-parsing systems. Its type system and memory control provide you with the ability to create high throughput data pipelines with a low and stable memory footprint. Small filter programs can be easily embedded into the larger framework via Apache Storm, Apache Kafka, or Apache Hadoop streaming.\n\n",
    "1.10.3 Extending applications Rust is well suited for extending programs written in a dynamic language. This enables JNI (Java Native Interface) extensions, C extensions, or Erlang/Elixir NIFs (native implemented functions) in Rust. C extensions are typically a scary proposition. These tend to be quite tightly integrated with the runtime. Make a mistake and you could be looking at runaway memory consumption due to a memory leak or a com- plete crash. Rust takes away a lot of this anxiety. * Sentry, a company that processes application errors, finds that Rust is an excellent candidate for rewriting CPU-intensive components of their Python system.20 * Dropbox used Rust to rewrite the file synchronization engine of its client-side application: \"More than performance, [Rust\u2019s] ergonomics and focus on cor- rectness have helped us tame sync\u2019s complexity.\"\n\n",
    "1.10.4 Resource-constrained environments C has occupied the domain of microcontrollers for decades. Yet, the Internet of Things (IoT) is coming. That could mean many billions of insecure devices exposed to the network. Any input parsing code will be routinely probed for weaknesses. Given how infrequently firmware updates for these devices occur, it\u2019s critical that these are as secure as possible from the outset. Rust can play an important role here by adding a layer of safety without imposing runtime costs.\n\n",
    "1.10.5 Server-side applications Most applications written in Rust live on the server. These could be serving web traffic or supporting businesses running their operations. There is also a tier of services that sit between the OS and your application. Rust is used to write databases, monitoring systems, search appliances, and messaging systems. For example * The npm package registry for the JavaScript and node.js communities is written in Rust.22 * sled (https://github.com/spacejam/sled), an embedded database, can process a workload of 1 billion operations that includes 5% writes in less than a minute on a 16-core machine. * Tantivy, a full text search engine, can index 8 GB of English Wikipedia in approximately 100 s on a 4-core desktop machine.23 1.10.6 Desktop applications There is nothing inherent in Rust\u2019s design that prevents it from being deployed to develop user-facing software. Servo, the web browser engine that acted as an incuba- tor for Rust\u2019s early development, is a user-facing application. Naturally, so are games.\n\n",
    "1.10.7 Desktop There is still a significant need to write applications that live on people\u2019s computers. Desktop applications are often complex, difficult to engineer, and hard to support. With Rust\u2019s ergonomic approach to deployment and its rigor, it is likely to become the secret sauce for many applications. To start, these will be built by small, independent developers. As Rust matures, so will the ecosystem.\n\n",
    "1.10.8 Mobile Android, iOS, and other smartphone operating systems generally provide a blessed path for developers. In the case of Android, that path is Java. In the case of macOS, developers generally program in Swift. There is, however, another way. Both platforms provide the ability for native applications to run on them. This is generally intended for applications written in C++, such as games, to be able to be deployed to people\u2019s phones. Rust is able to talk to the phone via the same interface with no additional runtime cost.\n\n",
    "1.10.9 Web As you are probably aware, JavaScript is the language of the web. Over time though, this will change. Browser vendors are developing a standard called WebAssembly (Wasm) that promises to be a compiler target for many languages. Rust is one of the first. Porting a Rust project to the browser requires only two additional command-line commands. Several companies are exploring the use of Rust in the browser via Wasm, notably CloudFlare and Fastly.\n\n",
    "1.10.10 Systems programming In some sense, systems programming is Rust\u2019s raison d\u2019\u00eatre. Many large programs have been implemented in Rust, including compilers (Rust itself), video game engines, and operating systems. The Rust community includes writers of parser generators, databases, and file formats.\n\n",
    "Rust has proven to be a productive environment for programmers who share Rust\u2019s goals. Three standout projects in this area include the following: * Google is sponsoring the development of Fuchsia OS, an operating system for devices.24 * Microsoft is actively exploring writing low-level components in Rust for Win- dows.25 * Amazon Web Services (AWS) is building Bottlerocket, a bespoke OS for hosting containers in the cloud.26\n\n",
    "1.11 Rust\u2019s hidden feature: Its community It takes more than software to grow a programming language. One of the things that the Rust team has done extraordinarily well is to foster a positive and welcoming com- munity around the language. Everywhere you go within the Rust world, you\u2019ll find that you\u2019ll be treated with courtesy and respect.\n\n",
    "1.12 Rust phrase book When you interact with members of the Rust community, you\u2019ll soon encounter a few terms that have special meaning. Understanding the following terms makes it easier to understand why Rust has evolved the way that it has and the problems that it attempts to solve: * Empowering everyone\u2014All programmers regardless of ability or background are welcome to participate. Programming, and particularly systems programming, should not be restricted to a blessed few. Blazingly fast\u2014Rust is a fast programming language. You\u2019ll be able to write pro- grams that match or exceed the performance of its peer languages, but you will have more safety guarantees. * Fearless concurrency\u2014Concurrent and parallel programming have always been seen as difficult. Rust frees you from whole classes of errors that have plagued its peer languages. * No Rust 2.0\u2014Rust code written today will always compile with a future Rust compiler. Rust is intended to be a reliable programming language that can be depended upon for decades to come. In accordance with semantic versioning, Rust is never backward-incompatible, so it will never release a new major ver- sion. * Zero-cost abstractions\u2014The features you gain from Rust impose no runtime cost. When you program in Rust, safety does not sacrifice speed.\n\n",
    "Summary * Many companies have successfully built large software projects in Rust. * Software written in Rust can be compiled for the PC, the browser, and the server, as well as mobile and IoT devices. * The Rust language is well loved by software developers. It has repeatedly won Stack Overflow\u2019s \"most loved programming language\" title. * Rust allows you to experiment without fear. It provides correctness guarantees that other tools are unable to provide without imposing runtime costs. * With Rust, there are three main command_line tools to learn: \u2013 cargo, which manages a whole crate \u2013 rustup, which manages Rust installations \u2013 rustc, which manages compilation of Rust source code * Rust projects are not immune from all bugs. * Rust code is stable, fast, and light on resources.\n\n",
    "Language foundations This chapter covers * Coming to grips with the Rust syntax * Learning fundamental types and data structures * Building command-line utilities * Compiling programsThis chapter introduces you to the fundamentals of Rust programming. By the end of the chapter, you will be able to create command-line utilities and should be able to get the gist of most Rust programs. We\u2019ll work through most of the language\u2019s syntax, but defer much of the detail about why things are how they are for later in the book.NOTE Programmers who have experience with another programming language will benefit the most from this chapter. If you are an experienced Rust programmer, feel free to skim through it.Beginners are welcomed. Rust\u2019s community strives to be responsive to newcomers. At times, you may strike a mental pothole when you encounter terms such as lifetime elision, hygienic macros, move semantics, and algebraic data types without context. Don\u2019t be afraid to ask for help. The community is much more welcoming than these helpful, yet opaque, terms might suggest.In this chapter, we will build grep-lite, a greatly stripped-down version of the ubiquitous grep utility. Our grep-lite program looks for patterns within text and prints lines that match. This simple program allows us to focus on the unique features of Rust.The chapter takes a spiral approach to learning. A few concepts will be discussed multiple times. With each iteration, you will find yourself learning more. Figure 2.1 shows a completely unscientific map of the chapter. Figure 2.1 Chapter topic outline. Starting with primitive types, the chapter progresses through several concepts with increasing levels of depth.It\u2019s highly recommended that you follow along with the examples in this book. As a reminder, to access or download the source code for the listings, use either of these two sources: * https://manning.com/books/rust-in-action * https://github.com/rust-in-action/code2.1 Creating a running program Every plain text file has a hidden superpower: when it includes the right symbols, it can be converted into something that can be interpreted by a CPU. That is the magic of a programming language. This chapter\u2019s aim is to allow you to become familiar with the process of converting Rust source code into a running program.Understanding this process is more fun than it sounds! And it sets you up for an exciting learning journey. By the end of chapter 4, you will have implemented a virtual CPU that can also interpret programs that you create.2.1.1 Compiling single files with rustc Listing 2.1 is a short, yet complete Rust program. To translate it into a working program, we use software called a compiler. The compiler\u2019s role is to translate the source code into machine code, as well as take care of lots of bookkeeping to satisfy the operating system (OS) and CPU that it is a runnable program. The Rust compiler is called rustc. You\u2019ll find the source code for listing 2.1 in the file ch2/ok.rs.Listing 2.1 Almost the shortest valid Rust programTo compile a single file written in Rust into a working program 1 Save your source code to a file. In our case, we\u2019ll use the filename ok.rs. 2 Make sure that the source code includes a main() function. 3 Open a shell window such as Terminal, cmd.exe, Powershell, bash, zsh, or any other. 4 Execute the command rustc <file>, where <file> is the file you want to compile.When compilation succeeds, rustc sends no output to the console. Behind the scenes, rustc has dutifully created an executable, using the input filename to choose the output filename.Assuming that you\u2019ve saved listing 2.1 to a file called ok.rs, let\u2019s see what that looks like. The following snippet provides a short demonstration of the process2.1.2 Compiling Rust projects with cargo Most Rust projects are larger than a single file. These typically include dependencies. To prepare ourselves for that, we\u2019ll use a higher-level tool than rustc, called cargo. cargo understands how to drive rustc (and much more).Migrating from a single file workflow managed by rustc to one managed by cargo is a two-stage process. The first is to move that original file into an empty directory. Then execute the cargo init command.Here is a detailed overview of that process, assuming that you are starting from a file called ok.rs generated by following the steps in the previous section: 1 Run mkdir <project> to create an empty directory (e.g., mkdir ok). 2 Move your source code into the <project> directory (e.g., mv ok.rs ok). 3 Change to the <project> directory (e.g., cd ok). 4 Run cargo init.From this point on, you can issue cargo run to execute your project\u2019s source code. One difference from rustc is that compiled executables are found in a <project>/ target subdirectory. Another is that cargo provides much more output by default:If you\u2019re ever curious about what cargo is doing under the hood to drive rustc, add the verbose flag (-v) to your command:2.2 A glance at Rust\u2019s syntax Rust is boring and predictable where possible. It has variables, numbers, functions, and other familiar things that you have seen in other languages. For example, it delimits blocks with curly brackets ({ and }), it uses a single equals sign as its assignment operator (=), and it is whitespace-agnostic.2.2.1 Defining variables and calling functions Let\u2019s look at another short listing to introduce some fundamentals: defining variables with type annotations and calling functions. Listing 2.2 prints ( a + b ) + ( c + d ) = 90 to the console. As you can see from lines 2\u20135 in the listing, there are multiple syntactic choices for annotating data types to integers. Use whichever feels most natural for the situation at hand. The source code for this listing is in ch2/ch2-first-steps.rs.Listing 2.2 Adding integers using variables and declaring typesNOTE In the listing, be careful about adding a semicolon to the add() function declaration. This changes the semantics, returning () (unit) rather than i32.Although there are only 13 lines of code, there is quite a lot packed into listing 2.2. Here\u2019s a brief description that should provide the gist of what\u2019s going on. We will cover the details in the rest of the chapter.In line 1 (fn main() {), the fn keyword begins a function definition. The entry point to all Rust programs is main(). It takes no arguments and returns no value.1 Code blocks, also known as lexical scopes, are defined with curly braces: { and }. 1 This isn\u2019t technically correct, but is accurate enough for now. If you\u2019re an experienced Rust programmer skimming through this chapter, you\u2019ll know that main() returns () (unit) by default and can also return a Result.In line 2 (let a = 10;), we use let to declare variable bindings. Variables are immutable by default, meaning that they are read-only rather than read-write. And finally, statements are delimited with semicolons (;).In line 3 (let b: i32 = 20;), you can designate a specific data type for the compiler. At times, this will be required as the compiler will be unable to deduce a unique type on your behalf.In line 4 (let c = 30i32;), you\u2019ll note that Rust\u2019s numeric literals can include types annotations. This can be helpful when navigating complex numerical expressions. And in line 5 (let c = 30_i32;), you\u2019ll see that Rust permits the use of underscores within numeric literals. These increase readability but are insignificant to the compiler. In line 6 (let e = add(add(a, b), add(c, d));), it should be easy to see that calling functions looks like what you\u2019ve experienced in most other programming languages.In line 8 (println!(\"( a + b ) + ( c + d ) = {}\", e); ), println!() is a macro, which is function-like but returns code rather than values. When printing to the console, every input data type has its own way of being represented as a text string. println!() takes care of figuring out the exact methods to call on its arguments.Strings use double quotes (\u201c) rather than single quotes (\u2019). Rust uses single quotes for single characters, which are a distinct type, char. And with Rust, string formatting uses {} as a placeholder, rather than the C-like printf style of %s or other variants.Finally, in line 10 (fn add(\u2026) -> i32 {), you can see that Rust\u2019s syntax for defining functions is similar to those programming languages that use explicit type declarations. Commas delimit parameters, and type declarations follow variable names. The dagger (->) or thin arrow syntax indicates the return type.2.3 Numbers Computers have been associated with numbers for longer than you have been able to say \"formula translator.\" This section discusses how to create numeric types in Rust and how to perform operations on these.2.3.1 Integers and decimal (floating-point) numbers Rust uses a relatively conventional syntax for creating integers (1, 2, \u2026) and floatingpoint numbers (1.0, 1.1, \u2026). Operations on numbers use infix notation, meaning that numeric expressions look like those that you\u2019re used to seeing in most programming languages. To operate on multiple types, Rust also allows the same token (+) for addition. This is called operator overloading. Some notable differences from other languages follow: * Rust includes a large number of numeric types. You will become used to declaring the size in bytes, which affects how many numbers the type can represent and whether your type is able to represent negative numbers. * Conversions between types are always explicit. Rust does not automatically convert your 16-bit integer into a 32-bit integer. * Rust\u2019s numbers can have methods. For example, to round 24.5 to the nearest integer, Rust programmers use 24.5_f32.round() rather than (round(24.5_f32)). Here, the type suffix is required because a concrete type is necessary.To start, let\u2019s consider a small example. You\u2019ll find the code in ch2/ch2-intro-tonumbers.rs in the examples for this book. Listing 2.3 prints these few lines to the console:Listing 2.3 Numeric literals and basic operations on numbers in Rust2.3.2 Integers with base 2, base 8, and base 16 notation Rust also has built-in support for numeric literals that allow you to define integers in base 2 (binary), base 8 (octal), and base 16 (hexadecimal). This notation is also available within the formatting macros like println!. Listing 2.4 demonstrates the three styles. You can find the source code for this listing in ch2/ch2-non-base2.rs. It produces the following output:Listing 2.4 Using base 2, base 8, and base 16 numeric literalsIn binary (base 2) numerals, 0b11 equals 3 because 3 = 2 \u00d7 1 + 1 \u00d7 1. With octal (base 8) numerals, 0o36 equals 30 because 30 = 8 \u00d7 3 + 1 \u00d7 6. And with hexadecimal (base 16) numerals, 0x12C equals 300 because 300 = 256 \u00d7 1 + 16 \u00d7 2 + 1 \u00d7 12. Table 2.1 shows the types that represent scalar numbers.Table 2.1 Rust types for representing scalar (single) numbersRust contains a full complement of numeric types. The types are grouped into a few families: * Signed integers (i) represent negative as well as positive integers. * Unsigned integers (u) only represent positive integers but can go twice as high as their signed counterparts. * Floating-point types (f) represent real numbers with special bit patterns to represent infinity, negative infinity, and \"not a number\" values.Integer width is the number of bits that the type uses in RAM and in the CPU. Types that take up more space, such as u32 vs.\u00a0i8, can represent a wider range of numbers. But this incurs the expense of needing to store extra zeros for smaller numbers, as table 2.2 shows.Table 2.2 Multiple bit patterns can represent the same number.Although we\u2019ve only touched on numbers, we nearly have enough exposure to Rust to create a prototype of our pattern-matching program. But let\u2019s look at comparing numbers before we create our program.2.3.3 Comparing numbers Rust\u2019s numeric types support a large suite of comparisons that you\u2019re probably familiar with. Enabling support for these comparisons is provided by a feature that you have not encountered yet. It is called traits.2 Table 2.3 summarizes the comparison operators available to you. 2 For the curious and eager, the traits involved here are std::cmp::PartialOrd and std::cmp::PartialEq.Table 2.3 Mathematical operators supported by Rust\u2019s numeric typesThat support does include a few caveats. We\u2019ll look at these conditions in the rest of this section.IMPOSSIBLE TO COMPARE DIFFERENT TYPES Rust\u2019s type safety requirements prevent comparisons between types. For example, this code does not compile:To appease the compiler, we need to use an as operator to cast one of the operands to the other\u2019s type. The following code shows this type cast: b as i32:It is safest to cast the smaller type to a larger one (for example, a 16-bit type to a 32-bit type). This is sometimes referred to as promotion. In this case, we could have demoted a down to a u16, but such a move is generally more risky.WARNING Using type casts carelessly will cause your program to behave unexpectedly. For example, the expression 300_i32 as i8 returns 44.In some cases, using the as keyword is too restrictive. It\u2019s possible to regain fuller control over the type conversion process at the cost of introducing some bureaucracy. The following listing shows a Rust method to use instead of the as keyword when the conversion might fail."
]